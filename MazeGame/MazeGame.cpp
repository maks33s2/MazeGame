// MazeGame.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <conio.h>
#include "time.h"
#include "windows.h"
#include "CrtLib.h"

using namespace std;
using namespace crt;

const int LX = 81;
const int LY = 32;

const char player = (char)1;
// 0 - пустое пространство
// 1 - стена 
// 2 - выход
// 3 - игрок
// 4 - монета
// 7 - мина
// 8 - мина2

int a = 0;
int b = 0;

void SetColor(int color) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
}

int maze[LY][LX] = {
{12,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,15,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11},
{9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9},
{9,1,1,1,4,1,0,0,0,0,0,0,0,0,0,0,1,1,0,4,0,0,0,0,0,4,1,0,0,0,0,0,0,0,0,0,0,1,1,0,4,0,0,0,0,0,4,1,0,0,0,0,0,0,0,0,0,0,1,1,0,4,0,0,0,0,0,4,1,0,0,0,0,0,0,2,9},
{9,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,9},
{9,1,1,0,1,1,1,1,1,4,1,1,1,1,1,4,0,0,0,0,1,1,1,1,0,1,1,1,1,1,4,1,1,1,1,1,4,0,0,0,0,1,1,1,1,0,1,1,1,1,1,4,1,1,1,1,1,4,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,1,1,9},
{9,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,1,9},
{9,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,4,1,0,1,1,9},
{9,1,1,0,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,9},
{9,1,1,0,1,4,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,4,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,4,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,4,0,0,0,1,1,9},
{9,1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,6,1,1,1,1,0,1,0,1,0,0,0,1,1,1,9},
{9,1,1,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,1,1,9},
{9,1,0,0,0,4,0,0,0,0,1,0,0,0,0,0,4,0,0,0,0,1,1,0,0,0,4,0,0,0,0,1,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,4,0,0,0,0,1,0,0,0,0,0,4,0,0,0,0,1,1,0,0,0,0,1,0,1,1,0,1,1,9},
{9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,9},
{9,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,4,1,1,1,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,4,1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,4,1,1,1,0,1,1,0,0,0,4,0,0,1,1,0,1,1,9},
{9,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,1,1,9},
{9,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,9},
{9,1,1,1,1,4,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,4,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,9},
{9,1,1,1,1,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,9},
{9,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,1,1,9},
{9,1,1,1,1,0,1,0,0,4,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,4,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,4,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,9},
{9,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,0,0,0,0,1,1,9},
{9,1,1,1,1,0,1,0,1,4,0,0,0,0,4,0,0,0,0,0,0,1,1,0,1,1,0,1,0,1,4,0,0,0,0,4,0,0,0,0,0,0,1,1,1,1,1,0,1,0,1,4,0,0,0,0,4,0,0,0,0,0,0,1,1,0,1,0,1,4,1,0,1,1,1,1,9},
{9,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,1,9},
{9,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,1,0,1,1,9},
{9,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,4,1,0,0,0,0,0,1,0,0,1,9},
{9,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,9},
{9,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,4,0,0,0,0,0,8,0,0,0,1,9},
{9,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,0,0,0,0,0,1,1,1,1,1,9},
{9,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,8,4,1,9},
{9,1,1,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,1,9},
{9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9},
{14,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,13}
};

// глобальные переменные
int hx, hy; // позиция игрока в лабиринте
int& hhx{ hx }, hhy{ hy };
int score = 0; // счет игры
int doll = 0;

int gameState = 0; // 0 - игра продолжается, 1 - выигрыш, 2 - закончилось время
int& gState{ gameState };
int timeLimit = 155; // лимит игры в секундах
int gameTime; // оставшееся время
int& gTime{ gameTime };

clock_t tstart; // значение счетчика таймера при старте игры
clock_t start = tstart;

// Функция обновляет текущий счет на экране
void UpdateScore(int score)
{
    SetColor(3); // Меняет цвет счёта
    GotoXY(30, 32); // ставим курсор на последнюю строку консоли
    setlocale(LC_ALL, "ru-RU"); // включаем локаль, ориентированную на кириллицу
    cout << "СЧЕТ: " << score;  // выводим счет на экран
    setlocale(LC_ALL, "C"); // возвращаем настройки локали по умолчанию
}

void UpdateDoll(int doll)
{
    SetColor(3); // Меняет цвет счёта
    GotoXY(78, 10); // ставим курсор на последнюю строку консоли
    setlocale(LC_ALL, "ru-RU"); // включаем локаль, ориентированную на кириллицу
    cout << "$ - " << doll;  // выводим счет на экран
    setlocale(LC_ALL, "C"); // возвращаем настройки локали по умолчанию
}

// Функция обновляет оставшееся время до окончания игры
// параметр t функции - это текущее значение системного таймера, на момент вызова функции
void UpdateClock(clock_t t, clock_t start, int& gTime, int& gState)
{
    SetColor(2);
    gTime = timeLimit - (t - start) / CLOCKS_PER_SEC; /* вычисляем оставшееся время в секундах
                    и помещаем результат в gameTime. (t-tstart) - кол-во миллисекунд, прошедшее
                    с момента старта игры. CLOCKS_PER_SEC - константа, определяющая количество
                    изменений системного таймера за 1 секунду. Для Windows это значение
                    равно 1000. Вычитая из timeLimit время, прошедшее с начала игры, мы вычисляем
                    остаток времени в секундах */
    setlocale(LC_ALL, "ru-RU"); // переключаем локаль
    if (gTime < 15) {
        SetColor(4); // Если время меньше 15 то перекрасить его в красный
    }
    if (gTime < 0) // проверяем, закончилось ли время
    {
        gState = 2; // если да, то обновляем статус игры на 2 - игрок ПРОИГРАЛ
    }
    else
    {  // если время осталось
        GotoXY(49, 32); // ставим курсор на последнюю строку
        cout << "Осталось: " << gTime << " секунд "; // выводим остаток времени в консоль
    }
    setlocale(LC_ALL, "C"); // восстанавливаем настройки локали
}

// Функция печатает в консоли лабиринт
void PrintMaze(int maze[LY][LX], int sizeX, int sizeY)
{
    for (int i = 0; i < sizeY; i++)
    {
        for (int j = 0; j < sizeX; j++)
        {
            switch (maze[i][j])
            {
            case 0:
                cout << ' ';
                break;
            case 1:
                SetColor(4); // Меняет цвет стенам
                cout << (char)178;
                break;
            case 2:
                SetColor(8); // Меняет цвет выходу
                cout << (char)176;
                break;
            case 3:
                SetColor(7); // Меняет цвет игроку
                cout << player;
                break;
            case 4:
                SetColor(6); // Меняет цвет монетам
                cout << '$';
                break;
            case 5:
                SetColor(3);
                cout << (char)4;
                break;
            case 6:
                SetColor(7);
                cout << (char)30;
                break;
            case 7:
                SetColor(8);
                cout << (char)15;
                break;
            case 8:
                SetColor(8);
                cout << (char)15;
                break;
            case 9:
                SetColor(15);
                cout << (char)179;
                break;
            case 10:
                SetColor(15);
                cout << (char)196;
                break;
            case 11:
                SetColor(15);
                cout << (char)191;
                break;
            case 12:
                SetColor(15);
                cout << (char)218;
                break;
            case 13:
                SetColor(15);
                cout << (char)217;
                break;
            case 14:
                SetColor(15);
                cout << (char)192;
                break;
            case 15:
                SetColor(15);
                cout << (char)139 << (char)128 << (char)129 << (char)136 << (char)144 << (char)136 << (char)141 << (char)146;
                break;
            case 16:
                SetColor(15);
                UpdateDoll(doll);
                break;
            default:
                cout << '?';
            }
        }
        cout << endl;
    }
}

// Функция определяет позицию игрока в массиве, обновляя значения глобальных переменных hx и hy
void FindFirstPlayerPosition(int maze[LY][LX], int sizeX, int sizeY)
{

    for (int i = 0; i < sizeY; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < sizeX; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 2)    // проверяем, если текущий элемент равен 3 - нашли
            {
                a++; // считает количество игроков
            }
        }
    }

    for (int i = 0; i < sizeY; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < sizeX; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 3)    // проверяем, если текущий элемент равен 3 - нашли
            {
                b++; // считает количество игроков
            }
        }
    }

    for (int i = 0; i < sizeY; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < sizeX; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 4)    // проверяем, если текущий элемент равен 3 - нашли
            {
                doll++; // считает количество $
            }
        }
    }

    if (a != 1 || b != 1) {
        gState = 2; // заканчивает игру если количество игроков или выходов не равно 1 
    }

    for (int i = 0; i < sizeY; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < sizeX; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 3)    // проверяем, если текущий элемент равен 3 - нашли
            {                       // требуемую позицию
                hhx = j;             // записываем столбец в hx
                hhy = i;             // записываем строку в hy
                SetColor(7);        // Меняет цвет персонажу при ходьбе
                return;             // завершаем работу функции
            }
        }
    }
}                   // это нелогично, но пока ничего предпринимать не будем, решение
                    // этой проблемы будет вашим персональным заданием по рефакторингу игры



//Функция скрывает игрока с экрана и убирает его из лабиринта
void HidePlayer()
{
    maze[hhy][hhx] = 0; // записываем в текущую позицию матрицы число 0
    GotoXY(hhx, hhy); // устанавливаем курсор в позицию игрока в консоль
    cout << ' ';    // и печатаем пробел
}

// функция показывает на экране игрока и записывает его в лабиринт
void ShowPlayer()
{
    maze[hhy][hhx] = 3; // записываем в текущую позицию матрицы число 0
    GotoXY(hhx, hhy); // устанавливаем курсор в позицию игрока в консоль
    cout << player; // и печатаем образ игрока
}


void MovePlayer(int dx, int dy)
{
    if (hhx + dx < LX && hhy + dy < LY && hhx + dx >= 0 && hhy + dy >= 0)
    {
        switch (maze[hhy + dy][hhx + dx]) { // Проверяем, что находится в ячейке матрицы 
        case 0: // Если там пусто, то ход возможен
            SetColor(7); // Меняет цвет персонажу при ходьбе
            HidePlayer(); // Скрываем игрока с экрана
            hhx += dx; // Обновляем координату x
            hhy += dy; // Обновляем координату y
            ShowPlayer(); // Отображаем игрока в новой позиции 
            break;
        case 2: // Если там дверь выхода
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateScore(score += 500); // Добавляем 500 бонусов за достижение выхода из лабиринта
            gState = 1; // Изменяем статус игры на ВЫИГРЫШ
            break;
        case 4: // Если там монета
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateScore(score += 100); // Добавляем 100 бонусов за сбор монеты
            UpdateDoll(doll -= 1);
            break;
        case 5: // Если там алмаз
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateScore(score += 300); // Добавляем 300 бонусов за сбор алмаза
            break;
        case 6: // Если там часы
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateClock(gTime = timeLimit += 10, start, gTime, gState); // Добавляем 10 секунд за сбор часов
            break;
        case 7: // Если там мина
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateScore(score -= 200); // Отнимает 200 очков за наступление на мину
            break;
        case 8: // Если там мина2
            HidePlayer();
            hhx += dx;
            hhy += dy;
            ShowPlayer();
            UpdateClock(gTime = timeLimit -= 8, start, gTime, gState); // Отнимает 8 секунд за наступление на мину2
            break;
        }
    }
}

void ShowGameOverMessage() {
    system("cls");
    setlocale(LC_ALL, "ru-RU");

    if (gState == 1) { // Если выигрыш
        SetTextColor(COLOR_LIGHT_GREEN); // Зеленый текст
        cout << "Вы выиграли! Ваш счет: " << score << endl;
    }
    else if (gState == 2) { // Если проигрыш
        SetTextColor(COLOR_RED); // Красный текст
        cout << "Вы проиграли. Ваш счет: " << score << endl;
    }

    SetTextColor(COLOR_WHITE); // Сброс цвета
    cout << "Нажмите любую клавишу для выхода...";
    _getch(); // Ждем нажатия клавиши
}

void Control(int& gState)
{
    start = clock();
    UpdateScore(score);
    unsigned char x; // Это переменная хранит символ, соответствующий нажатой клавише
    while (gState == 0) // Цикл игры - пока gameState == 0, игра идет
    {
        UpdateClock(clock(), start, gTime, gState); // Обновляем оставшееся время 
        if (_kbhit()) {// Если была нажата клавиша - то обрабатываем ее, иначе следующая итерация игрового цикла 
            x = _getch(); // Считываем символ нажатой клавиш 
            if (x == 27) return; // Если это символ Esc (27) то это выход из игры
            if (x == 0xe0) // Если это символ с кодом 0xE0 (шестнадцатеричное)
                switch (_getch()) // Считываем еще один символ (некоторые клавиши выдают двойные коды)
                {
                case 72: // Если 2-й символ код 72, то это клавиша курсор вверх
                    MovePlayer(0, -1); // Идем вверх
                    break;
                case 80: // Если 2-й символ код 80, то это клавиша курсор вниз
                    MovePlayer(0, 1); // Идем вниз 
                    break;
                case 75: // Если 2-й символ код 75, то это клавиша курсор влево
                    MovePlayer(-1, 0); // Идем влево 
                    break;
                case 77: // Если 2-й символ код 77, то это клавиша курсор вправо 
                    MovePlayer(1, 0); // Идем вправо
                    break;
                }
        }
        Sleep(150); // Останавливаем игру на 200 мсек
    }
}

// Функция main, которая выполняется при запуске прграммы
int main()
{
    system("mode con cols=90 lines=33");
    system("cls");
    PrintMaze(maze, LX, LY);
    FindFirstPlayerPosition(maze, LX, LY);
    UpdateDoll(doll);
    HideCursor();
    Control(gState);
    ShowCursor();
    ShowGameOverMessage();
}

